{"name":"Biometria exercício Aula 09","tagline":"Link criado para expor as informações do exercício. A formatação e apresentação dos códigos e resultados foi feita usando o suporte do Markdown.","body":"**Exercício da disciplina de Biometria de Marcadores Genéticos (Relativo à aula 09)**\r\n\r\n**Discente: Gabriel Costa Monteiro Moreira (número USP: 7840511)**\r\n\r\n**Objetivo: Fixar os conceitos apresentados em aula. Aprender a realizar mapeamento por intervalo usando a aproximação de Haley-Knott.**\r\n\r\nQuestão 2) Faça mapeamento de QTL’s no conjunto de dados Mouse Data usando a aproximação de Haley-Knott.\r\n\r\nUse probabilidades de dois pontos para fazer inferências sobre eventual QTL no intervalo entre dois marcadores (usando a “famosa” tabela discutida durante a aula).\r\n\r\nLembre-se que em situações reais o ideal seria usar probabilidades multiponto; tal estratégia não será usada no exercício apenas por razões didáticas. Use somente adaptações de códigos em R usados em listas anteriores e apresentados em aula (função lm(), etc), ou seja, não use o R/qtl ou programa similar para fazer as análises, mas sim funções do R desenvolvidas para realizar regressões lineares.\r\n\r\nSe preferir, use alguma planilha eletrônica para calcular as probabilidades condicionais. Apresente o resultado em um gráfico, e também uma tabela com o(s) valor(es) do(s) QTL(s) mapeado(s), de forma semelhante ao apresentado na literatura (efeitos, LOD, etc).\r\n\r\nAssuma que o threshold é 1.43 (LOD). O objetivo do exercício é entender os fundamentos estatísticos e de programação envolvidos, e não os resultados em si.\r\n\r\nO exercício pode ser feito pelo mesmo grupo que analisou os dados de Mimulus.\r\n\r\n**Considerando o enunciado da questão, o exercício foi elaborado em parceria com a discente Thaís Fernanda Godoy.**\r\n**Abaixo, segue lista de comandos que utilizamos no R para responder o exercício.**\r\n\r\n```\r\nmouse <- read.csv(\"http://dl.dropbox.com/u/1968009/mouse.csv\")\r\nmouse2<-mouse[2:16]\r\nmap<-c(0, 6.8, 1.0, 1.0, 2.9, 2.9, 4.9, 3.9, 1.0, 1.9, 1.9, 2.9, 6.8, 10.8)\r\nmap<-cumsum(map)\r\nmap\r\nk_mf<-function(m)\r\n  0.5 * tanh(m/50)\r\nret.pred<-function(x, y, theta){\r\n  if(x==1 & y==1) return(1)\r\n  else if(x==1 & y==0) return(1-theta)\r\n  else if(x==0 & y==1) return(theta)\r\n  else if(x==0 & y==0) return(0)\r\n  else stop\r\n}\r\ninterv<-diff(map)\r\nres<-numeric()\r\nfor(k in 2:(ncol(mouse2)-1)){\r\n  m<-seq(from=0, to=interv[k-1], by=1)\r\n  theta<-k_mf(m)/k_mf(interv[1])\r\n  temp.all<-numeric()\r\n  for(j in 1:nrow(mouse2)){\r\n    temp<-numeric(length(theta))\r\n    for(i in 1:length(theta)){\r\n      temp[i]<-ret.pred(x=mouse2[j,k], y=mouse2[j,k+1],theta[i])\r\n    }\r\n    temp.all<-rbind(temp.all, temp)\r\n  }\r\n  res<-cbind(res, temp.all)\r\n}\r\nF<-numeric(ncol(res))\r\nR2<- numeric(ncol(res))\r\nefect<- numeric(ncol(res))\r\nfor(i in 1:ncol(res)){\r\n  model<-summary(lm(mouse2[,1] ~ res[,i]))\r\n  print (model)\r\n  F[i-1]<-(round((model$fstatistic[1]),2))\r\n  R2[i-1]<- (round((model$r.squared),2))\r\n  efect[i-1]<- (round((model$coefficients[2,1]),2))\r\n}\r\nF\r\nLOD <- (round(((103/2)*(log10((F*1/101)+1))),2))\r\nLOD\r\nR2*100\r\nefect\r\nplot(LOD, type=\"l\", ylab=\"LOD score\", xlab=\"Localização (cM)\", ylim=c(0,8),\r\n     xlim=c(0,50), lwd=3)\r\nabline(h=1.43, col=\"blue\", lty=3, lwd=3)\r\nfinal<-data.frame(LOD,R2,efect)\r\nfinal\r\n```\r\n\r\n**RESULTADOS**\r\n\r\nAo final das análises, criamos uma tabela com os valores respectivos de LOD, R2 e efect. \r\nA tabela pode ser visualizada aqui [Tabela 01](https://cloud.githubusercontent.com/assets/12286650/8119076/4976c02e-1069-11e5-806e-ab1892818583.jpg)\r\n\r\nAlém da tabela, geramos o gráfico com os valores do LOD score e a localização em cM.\r\nO gráfico pode ser visualizado no link a seguir [Gráfico](https://cloud.githubusercontent.com/assets/12286650/8119178/05b41020-106a-11e5-8ea6-faa5b6f6ed54.jpeg)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}